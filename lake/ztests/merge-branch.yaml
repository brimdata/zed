script: |
  export ZED_LAKE_ROOT=test
  zed lake init -q
  zed lake create -q -orderby k POOL
  zed lake use -q POOL@main
  zed lake load -q -message "initial load of a.zson into main" a.zson
  zed lake use -q -b child
  zed lake load -q -message "initial load of b.zson into child" b.zson
  echo === main ===
  zed lake query -z "from POOL@main"
  echo === child ===
  zed lake query -z "from POOL@child"
  echo === child after merge ===
  zed lake merge -q main
  zed lake query -z "from POOL@child"
  echo === main after merge ===
  zed lake query -z "from POOL@main"
  echo === main after load c ===
  zed lake load -q -use POOL@main c.zson
  zed lake query -z "from POOL@main"
  echo === child after main load c ===
  zed lake query -z "from POOL@child"
  echo === main after child load a and merge ===
  zed lake load -q a.zson
  zed lake merge -q main
  zed lake query -z "from POOL@main"

inputs:
  - name: a.zson
    data: |
      {k:0,a:1}
  - name: b.zson
    data: |
      {k:1,b:1}
  - name: c.zson
    data: |
      {k:2,c:1}

outputs:
  - name: stdout
    data: |
      === main ===
      {k:0,a:1}
      === child ===
      {k:0,a:1}
      {k:1,b:1}
      === child after merge ===
      {k:0,a:1}
      {k:1,b:1}
      === main after merge ===
      {k:0,a:1}
      {k:1,b:1}
      === main after load c ===
      {k:0,a:1}
      {k:1,b:1}
      {k:2,c:1}
      === child after main load c ===
      {k:0,a:1}
      {k:1,b:1}
      === main after child load a and merge ===
      {k:0,a:1}
      {k:0,a:1}
      {k:1,b:1}
      {k:2,c:1}
